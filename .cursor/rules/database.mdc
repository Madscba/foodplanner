---
description: SQLAlchemy and Neo4j database patterns
globs: "**/models.py,**/database.py,**/graph/*.py,**/repository.py"
alwaysApply: false
---

# Database Conventions

## SQLAlchemy Models (PostgreSQL)

### Model Definition Pattern

```python
from datetime import datetime
from sqlalchemy import String, DateTime, func
from sqlalchemy.orm import Mapped, mapped_column, relationship

from foodplanner.database import Base


class Product(Base):
    __tablename__ = "products"

    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(200), nullable=False)
    ean: Mapped[str | None] = mapped_column(String(13), unique=True, index=True)
    price: Mapped[float] = mapped_column(nullable=False)
    store_id: Mapped[int] = mapped_column(ForeignKey("stores.id"))
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now()
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now()
    )

    # Relationships
    store: Mapped["Store"] = relationship(back_populates="products")
```

### Async Session Usage

```python
# Correct: Use dependency injection
from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import Depends

async def get_products(db: AsyncSession = Depends(get_db)) -> list[Product]:
    result = await db.execute(select(Product))
    return result.scalars().all()

# Incorrect: Manual session creation
async def get_products():
    async with AsyncSession(engine) as session:  # Don't do this in endpoints
        ...
```

### Query Patterns

```python
from sqlalchemy import select, and_, or_
from sqlalchemy.orm import selectinload

# Eager loading relationships
stmt = (
    select(Recipe)
    .options(selectinload(Recipe.ingredients))
    .where(Recipe.id == recipe_id)
)

# Filtering with multiple conditions
stmt = (
    select(Product)
    .where(
        and_(
            Product.store_id == store_id,
            Product.price < max_price
        )
    )
    .order_by(Product.price.asc())
)
```

---

## Neo4j (Knowledge Graph)

### Connection Pattern

```python
from neo4j import AsyncGraphDatabase

class GraphDatabase:
    def __init__(self, uri: str, user: str, password: str):
        self._driver = AsyncGraphDatabase.driver(uri, auth=(user, password))

    async def close(self):
        await self._driver.close()

    async def execute_query(self, query: str, **params) -> list[dict]:
        async with self._driver.session() as session:
            result = await session.run(query, **params)
            return [record.data() async for record in result]
```

### Cypher Query Patterns

```python
# Create recipe with ingredients (MERGE for idempotency)
CREATE_RECIPE = """
MERGE (r:Recipe {id: $recipe_id})
SET r.name = $name, r.instructions = $instructions
WITH r
UNWIND $ingredients AS ing
MERGE (i:Ingredient {name: ing.name})
MERGE (r)-[:CONTAINS {quantity: ing.quantity, measure: ing.measure}]->(i)
RETURN r
"""

# Find recipes with discounted ingredients
RECIPES_BY_DISCOUNT = """
MATCH (p:Product)-[:HAS_DISCOUNT]->(d:Discount)
WHERE d.valid_to >= date()
MATCH (i:Ingredient)-[m:MATCHES]->(p)
WHERE m.confidence_score > $threshold
MATCH (r:Recipe)-[:CONTAINS]->(i)
RETURN r, collect(DISTINCT i.name) as discounted_ingredients
ORDER BY size(discounted_ingredients) DESC
LIMIT $limit
"""
```

### Graph Model Classes

```python
from pydantic import BaseModel

class RecipeNode(BaseModel):
    """Pydantic model for Recipe graph node."""
    id: str
    name: str
    instructions: str | None = None
    thumbnail_url: str | None = None

    @classmethod
    def from_neo4j(cls, record: dict) -> "RecipeNode":
        """Convert Neo4j record to Pydantic model."""
        return cls(**record)
```

### Repository Pattern

```python
class RecipeRepository:
    def __init__(self, graph_db: GraphDatabase):
        self._db = graph_db

    async def create(self, recipe: RecipeCreate) -> RecipeNode:
        result = await self._db.execute_query(
            CREATE_RECIPE,
            recipe_id=recipe.id,
            name=recipe.name,
            instructions=recipe.instructions,
            ingredients=[ing.model_dump() for ing in recipe.ingredients]
        )
        return RecipeNode.from_neo4j(result[0])

    async def find_by_discounts(
        self, threshold: float = 0.7, limit: int = 10
    ) -> list[RecipeNode]:
        results = await self._db.execute_query(
            RECIPES_BY_DISCOUNT,
            threshold=threshold,
            limit=limit
        )
        return [RecipeNode.from_neo4j(r) for r in results]
```

## Key Principles

1. **Use MERGE for idempotency** - Safe for reruns
2. **Parameterize all queries** - Prevent injection
3. **Index frequently queried properties** - `CREATE INDEX ON :Product(ean)`
4. **Keep Cypher readable** - Use multi-line strings with comments
